Image.c
First, in the CreateImage function, define image as a pointer of IMAGE and make allocation of that variable to the size of IMAGE. If image has not been created, error appears and exits. Set the pointer of W and H with the parameter that was given from the CreateImage function. Set the pointers of RGB to NULL in case for errors. For the pointers of RGB, make allocations with the size of the image using the pointers of W and H. Then return image. Next is the DeleteImage function, first is to assert image, because it was called upon in the parameter. Next is to free all the variables that made allocation such as the pointers of RGB and image itself. For the function: ImageWidth and ImageHeight, first assert image then return the pointer of its’ value. For the GetPixelColors, first assert image because of the parameter, then return the pointer’s color with the array location of (x + y *image->W). The SetPixelColors: assert image then set the color of the array location (x + y *image->W) to the color on the parameter. 

DIPs.c
Change all the function names to match DIPs.h file. Change WIDTH to ImageWidth(image) and HEIGHT to ImageHeight(image). For the initial RGB arrays to obtain the original image, substitute with GetPixelR/G/B(image, x, y). For the altering of image, use SetPixelR/G/B(image, x, y, (altered color)).

Advanced.c
For functions: noise, posterize, and motion blur, use the same alteration as DIPs.c. For the Enlarge function, I first create a new image because the size of image has been changed with the percentage/100 times the original size. If the image is 100%, then the pixel displays the image as normal. If the percentage is over 100%, it runs through a new calculation of the location for the new image. Make loops to duplicate the pixel to make sure that each pixel is filled. DeleteImage(image) and set image to NULL so it can free the allocation of the original image called. Return the new image. The Square function also creates a new image with the size L by L. Make if statements if the L passes off bounds of the image based on offset values. Set the RGB values into the new image, then DeleteImage(image) and set image to NULL to free the allocation of the original image, then return the altered image. For the BrightnessAndContrast function, set the brightness and contrast variables to the max number if the user calls a number off bound. SetPixelR/G/B with the original RGB + brightness. Make the factor calculation to correct with the contrast. Use temporary variables to calculate the factor of the new RGB values. If those temporary values reach off bound, set them as the max colors such as 0 and 255, then SetPixelR/G/B with the temp colors.

PhotoLab.c
First is to alter the menu function accordingly. Declare variables needed form user input of each function that’s needed. Create another variable with parameter IMAGE. Make a switch statement for user’s input based upon the menu selection. For the SaveImage case, if the other functions have not been called, use the original file. This case asks for users’ input to save this new image as then deletes the new image and sets to null to free the allocation. The other case statements open the original image, then runs the function based on the menu. For the Enlarge function, it tells the user a warning if they inputted a percentage lower than 100% and loops until user gives the correct input. 

Makefile
For all the .o files, add Image.h in the parameters because they all use Image.h. Under IMAGES, add enlarge.ppm, square.ppm, and brightnessandcontrast.ppm. For PhotoLab.o and PhotoLab_DEBUG.o , add Test.h because they use the autotest functions. Create an Image.o file with Image.c and Image.h as the parameter. For the Test.o, create two separate .o files because one needs to run with DEBUG on and one with DEBUG off. For the compliable files, add Test.o and Image.o 

All .c and .h files, I add #include<Image.h> since they all require image altering. For PhotoLab.c, I also add #include<Test.h> since that’s the only .c file that uses autotest.

